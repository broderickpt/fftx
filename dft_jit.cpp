//g++ dft_jit.cpp -o dft_jit -I /usr/local/cuda-11.7/include -L /usr/local/cuda-11.7/lib -L /usr/local/cuda-11.7/lib64/ -lnvrtc -lcuda -Wl,-rpath,/usr/local/cuda-11.7/lib64  
//./dft_jit /usr/local/cuda-11.3/lib64/libcudadevrt.a 
#include <nvrtc.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <iostream>
#include <string>
#include <vector>
#define NVRTC_SAFE_CALL(x) \
 do { \
 nvrtcResult result = x; \
 if (result != NVRTC_SUCCESS) { \
 std::cerr << "\nerror: " #x " failed with error " \
 << nvrtcGetErrorString(result) << '\n'; \
 exit(1); \
 } \
 } while(0)
#define CUDA_SAFE_CALL(x) \
 do { \
 CUresult result = x; \
 if (result != CUDA_SUCCESS) { \
 const char *msg; \
 cuGetErrorName(result, &msg); \
 std::cerr << "\nerror: " #x " failed with error " \
 << msg << '\n'; \
 exit(1); \
 } \
 } while(0)
/*
 * This code was generated by Spiral 8.3.0, www.spiral.net
 */




const char * kernels ="__device__ double P1[128];\n\
__device__ double D1[128];\n\
extern \"C\" __global__ void ker_grid_dft2d_cont0(double  *X) {\n\
    double a252, a253, a254, a255, s61, s62, s63, s64, \n\
            s65, s66, s67, s68, s69, s70, s71, s72, \n\
            s73, s74, s75, s76, s77, s78, s79, s80, \n\
            t173, t174, t175, t176, t177, t178, t179, t180, \n\
            t181, t182, t183, t184, t185, t186, t187, t188, \n\
            t189, t190, t191, t192, t193, t194, t195, t196, \n\
            t197, t198, t199, t200; \n\
    int a250, a251, a256, b65; \n\
    a250 = (threadIdx.x % 8);\n\
    b65 = ((256*blockIdx.x) + (128*(threadIdx.x / 8)));\n\
    a251 = (b65 + (2*a250));\n\
    s61 = X[a251];\n\
    s62 = X[(a251 + 1)];\n\
    s63 = X[(a251 + 64)];\n\
    s64 = X[(a251 + 65)];\n\
    t173 = (s61 + s63);\n\
    t174 = (s62 + s64);\n\
    t175 = (s61 - s63);\n\
    t176 = (s62 - s64);\n\
    s65 = X[(a251 + 16)];\n\
    s66 = X[(a251 + 17)];\n\
    s67 = X[(a251 + 80)];\n\
    s68 = X[(a251 + 81)];\n\
    t177 = (s65 + s67);\n\
    t178 = (s66 + s68);\n\
    a252 = (0.70710678118654757*(s65 - s67));\n\
    a253 = (0.70710678118654757*(s66 - s68));\n\
    s69 = (a252 + a253);\n\
    s70 = (a253 - a252);\n\
    s71 = X[(a251 + 32)];\n\
    s72 = X[(a251 + 33)];\n\
    s73 = X[(a251 + 96)];\n\
    s74 = X[(a251 + 97)];\n\
    t179 = (s71 + s73);\n\
    t180 = (s72 + s74);\n\
    t181 = (s71 - s73);\n\
    t182 = (s72 - s74);\n\
    s75 = X[(a251 + 48)];\n\
    s76 = X[(a251 + 49)];\n\
    s77 = X[(a251 + 112)];\n\
    s78 = X[(a251 + 113)];\n\
    t183 = (s75 + s77);\n\
    t184 = (s76 + s78);\n\
    a254 = (0.70710678118654757*(s76 - s78));\n\
    a255 = (0.70710678118654757*(s75 - s77));\n\
    s79 = (a254 - a255);\n\
    s80 = (a255 + a254);\n\
    t185 = (t173 + t179);\n\
    t186 = (t174 + t180);\n\
    t187 = (t173 - t179);\n\
    t188 = (t174 - t180);\n\
    t189 = (t177 + t183);\n\
    t190 = (t178 + t184);\n\
    t191 = (t177 - t183);\n\
    t192 = (t178 - t184);\n\
    a256 = (b65 + (16*a250));\n\
    P1[a256] = (t185 + t189);\n\
    P1[(a256 + 1)] = (t186 + t190);\n\
    P1[(a256 + 8)] = (t185 - t189);\n\
    P1[(a256 + 9)] = (t186 - t190);\n\
    P1[(a256 + 4)] = (t187 + t192);\n\
    P1[(a256 + 5)] = (t188 - t191);\n\
    P1[(a256 + 12)] = (t187 - t192);\n\
    P1[(a256 + 13)] = (t188 + t191);\n\
    t193 = (t175 + t182);\n\
    t194 = (t176 - t181);\n\
    t195 = (t175 - t182);\n\
    t196 = (t176 + t181);\n\
    t197 = (s69 + s79);\n\
    t198 = (s70 - s80);\n\
    t199 = (s69 - s79);\n\
    t200 = (s70 + s80);\n\
    P1[(a256 + 2)] = (t193 + t197);\n\
    P1[(a256 + 3)] = (t194 + t198);\n\
    P1[(a256 + 10)] = (t193 - t197);\n\
    P1[(a256 + 11)] = (t194 - t198);\n\
    P1[(a256 + 6)] = (t195 + t200);\n\
    P1[(a256 + 7)] = (t196 - t199);\n\
    P1[(a256 + 14)] = (t195 - t200);\n\
    P1[(a256 + 15)] = (t196 + t199);\n\
}\n\
\n\
extern \"C\" __global__ void ker_grid_dft2d_cont1(double  *Y) {\n\
    double a749, a750, a751, a752, a757, a758, a759, a760, \n\
            a761, a762, a767, a768, a769, a770, a775, a776, \n\
            a777, a778, a779, a780, s189, s190, s191, s192, \n\
            s193, s194, s195, s196, s197, s198, s199, s200, \n\
            s201, s202, s203, s204, s205, s206, s207, s208, \n\
            s209, s210, s211, s212, s213, s214, s215, s216, \n\
            s217, s218, s219, s220, s221, s222, s223, s224, \n\
            t325, t326, t327, t328, t329, t330, t331, t332, \n\
            t333, t334, t335, t336, t337, t338, t339, t340, \n\
            t341, t342, t343, t344, t345, t346, t347, t348, \n\
            t349, t350, t351, t352;\n\
    int a743, a744, a745, a746, a747, a748, a753, a754, \n\
            a755, a756, a763, a764, a765, a766, a771, a772, \n\
            a773, a774;\n\
    a743 = (threadIdx.x % 8);\n\
    a744 = ((256*blockIdx.x) + (128*(threadIdx.x / 8)) + (2*a743));\n\
    s189 = P1[a744];\n\
    a745 = (a744 + 1);\n\
    s190 = P1[a745];\n\
    a746 = (a744 + 64);\n\
    s191 = P1[a746];\n\
    a747 = (a744 + 65);\n\
    s192 = P1[a747];\n\
    a748 = (16*a743);\n\
    a749 = D1[a748];\n\
    a750 = D1[(a748 + 1)];\n\
    s193 = ((a749*s189) - (a750*s190));\n\
    s194 = ((a750*s189) + (a749*s190));\n\
    a751 = D1[(a748 + 2)];\n\
    a752 = D1[(a748 + 3)];\n\
    s195 = ((a751*s191) - (a752*s192));\n\
    s196 = ((a752*s191) + (a751*s192));\n\
    t325 = (s193 + s195);\n\
    t326 = (s194 + s196);\n\
    t327 = (s193 - s195);\n\
    t328 = (s194 - s196);\n\
    a753 = (a744 + 16);\n\
    s197 = P1[a753];\n\
    a754 = (a744 + 17);\n\
    s198 = P1[a754];\n\
    a755 = (a744 + 80);\n\
    s199 = P1[a755];\n\
    a756 = (a744 + 81);\n\
    s200 = P1[a756];\n\
    a757 = D1[(a748 + 4)];\n\
    a758 = D1[(5 + a748)];\n\
    s201 = ((a757*s197) - (a758*s198));\n\
    s202 = ((a758*s197) + (a757*s198));\n\
    a759 = D1[(6 + a748)];\n\
    a760 = D1[(7 + a748)];\n\
    s203 = ((a759*s199) - (a760*s200));\n\
    s204 = ((a760*s199) + (a759*s200));\n\
    t329 = (s201 + s203);\n\
    t330 = (s202 + s204);\n\
    a761 = (0.70710678118654757*(s201 - s203));\n\
    a762 = (0.70710678118654757*(s202 - s204));\n\
    s205 = (a761 + a762);\n\
    s206 = (a762 - a761);\n\
    a763 = (a744 + 32);\n\
    s207 = P1[a763];\n\
    a764 = (a744 + 33);\n\
    s208 = P1[a764];\n\
    a765 = (a744 + 96);\n\
    s209 = P1[a765];\n\
    a766 = (a744 + 97);\n\
    s210 = P1[a766];\n\
    a767 = D1[(a748 + 8)];\n\
    a768 = D1[(9 + a748)];\n\
    s211 = ((a767*s207) - (a768*s208));\n\
    s212 = ((a768*s207) + (a767*s208));\n\
    a769 = D1[(10 + a748)];\n\
    a770 = D1[(11 + a748)];\n\
    s213 = ((a769*s209) - (a770*s210));\n\
    s214 = ((a770*s209) + (a769*s210));\n\
    t331 = (s211 + s213);\n\
    t332 = (s212 + s214);\n\
    t333 = (s211 - s213);\n\
    t334 = (s212 - s214);\n\
    a771 = (a744 + 48);\n\
    s215 = P1[a771];\n\
    a772 = (a744 + 49);\n\
    s216 = P1[a772];\n\
    a773 = (a744 + 112);\n\
    s217 = P1[a773];\n\
    a774 = (a744 + 113);\n\
    s218 = P1[a774];\n\
    a775 = D1[(a748 + 12)];\n\
    a776 = D1[(13 + a748)];\n\
    s219 = ((a775*s215) - (a776*s216));\n\
    s220 = ((a776*s215) + (a775*s216));\n\
    a777 = D1[(14 + a748)];\n\
    a778 = D1[(15 + a748)];\n\
    s221 = ((a777*s217) - (a778*s218));\n\
    s222 = ((a778*s217) + (a777*s218));\n\
    t335 = (s219 + s221);\n\
    t336 = (s220 + s222);\n\
    a779 = (0.70710678118654757*(s220 - s222));\n\
    a780 = (0.70710678118654757*(s219 - s221));\n\
    s223 = (a779 - a780);\n\
    s224 = (a780 + a779);\n\
    t337 = (t325 + t331);\n\
    t338 = (t326 + t332);\n\
    t339 = (t325 - t331);\n\
    t340 = (t326 - t332);\n\
    t341 = (t329 + t335);\n\
    t342 = (t330 + t336);\n\
    t343 = (t329 - t335);\n\
    t344 = (t330 - t336);\n\
    Y[a744] = (t337 + t341);\n\
    Y[a745] = (t338 + t342);\n\
    Y[a746] = (t337 - t341);\n\
    Y[a747] = (t338 - t342);\n\
    Y[a763] = (t339 + t344);\n\
    Y[a764] = (t340 - t343);\n\
    Y[a765] = (t339 - t344);\n\
    Y[a766] = (t340 + t343);\n\
    t345 = (t327 + t334);\n\
    t346 = (t328 - t333);\n\
    t347 = (t327 - t334);\n\
    t348 = (t328 + t333);\n\
    t349 = (s205 + s223);\n\
    t350 = (s206 - s224);\n\
    t351 = (s205 - s223);\n\
    t352 = (s206 + s224);\n\
    Y[a753] = (t345 + t349);\n\
    Y[a754] = (t346 + t350);\n\
    Y[a755] = (t345 - t349);\n\
    Y[a756] = (t346 - t350);\n\
    Y[a771] = (t347 + t352);\n\
    Y[a772] = (t348 - t351);\n\
    Y[a773] = (t347 - t352);\n\
    Y[a774] = (t348 + t351);\n\
}\n\
\n\
extern \"C\" __global__ void grid_dft2d_cont(double  *Y, double  *X) {\n\
    dim3 b129(16, 1, 1), b130(16, 1, 1), g1(2, 1, 1), g2(2, 1, 1);\n\
    ker_grid_dft2d_cont0<<<g1, b129>>>(X);\n\
    ker_grid_dft2d_cont1<<<g2, b130>>>(Y);\n\
}";

// void destroy_grid_dft2d_cont() {
//     double  *hp1;
//     cudaMemcpyFromSymbol(&(hp1), P1, sizeof(double  *));
//     cudaFree(hp1);
// }

void init_grid_dft2d_cont() {
    double  *hp1;
    cudaDeviceSetLimit(cudaLimitMallocHeapSize, 1073741824);
    // cudaFuncSetCacheConfig(ker_grid_dft2d_cont0, cudaFuncCachePreferL1);
    // cudaFuncSetCacheConfig(ker_grid_dft2d_cont1, cudaFuncCachePreferL1);
    // cudaMalloc(((void  * *) &(hp1)), (sizeof(double )*512));
    // cudaMemcpyToSymbol(P1, &(hp1), sizeof(double  *));
}


int main(int argc, char *argv[]) {
     if (argc < 2) {
    std::cout << "Usage: dynamic-parallelism <path to cudadevrt library>\n\n"
              << "<path to cudadevrt library> must include the cudadevrt\n"
              << "library name itself, e.g., Z:\\path\\to\\cudadevrt.lib on \n"
              << "Windows and /path/to/libcudadevrt.a on Linux.\n";
    exit(1);
  }
    size_t numBlocks = 16;
    size_t numThreads = 2;
    nvrtcProgram prog;
    NVRTC_SAFE_CALL(
    nvrtcCreateProgram(&prog, // prog
    kernels, // buffer
    "dft_jit.cpp", // name
    0, // numHeaders
    NULL, // headers
    NULL)); // includeNames
    // Compile the program for compute_35 with rdc enabled.
    const char *opts[] = {"--device-debug", "--generate-line-info","--gpu-architecture=compute_60",
    "--relocatable-device-code=true"};

    // std::vector<std::string> kernel_names;
    // kernel_names.push_back("ker_grid_dft2d_cont0");
    // kernel_names.push_back("ker_grid_dft2d_cont1");
    // kernel_names.push_back("ker_grid_dft2d_cont");
    // for(int i = 0; i < kernel_names.size(); i++) {
    //       NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, kernel_names[i].c_str()));
    // }
    std::vector<std::string> variables;

    variables.push_back("P1");
    variables.push_back("D1");
    for(int i = 0; i < variables.size(); i++) {
        NVRTC_SAFE_CALL(nvrtcAddNameExpression(prog, variables[i].c_str()));
    }
    nvrtcResult compileResult = nvrtcCompileProgram(prog, // prog
    4, // numOptions
    opts); // options
    // Obtain compilation log from the program.
    size_t logSize;
    NVRTC_SAFE_CALL(nvrtcGetProgramLogSize(prog, &logSize));
    char *log = new char[logSize];
    NVRTC_SAFE_CALL(nvrtcGetProgramLog(prog, log));
    std::cout << log << '\n';
    delete[] log;
    if (compileResult != NVRTC_SUCCESS) {
    exit(1);
    }
    // Obtain PTX from the program.
    size_t ptxSize;
    NVRTC_SAFE_CALL(nvrtcGetPTXSize(prog, &ptxSize));
    char *ptx = new char[ptxSize];
    NVRTC_SAFE_CALL(nvrtcGetPTX(prog, ptx));
    // Destroy the program.
    NVRTC_SAFE_CALL(nvrtcDestroyProgram(&prog));
    // Load the generated PTX and get a handle to the parent kernel.
    CUdevice cuDevice;
    CUcontext context;
    CUlinkState linkState;
    CUmodule module;
    CUfunction kernel;
    CUDA_SAFE_CALL(cuInit(0));
    CUDA_SAFE_CALL(cuDeviceGet(&cuDevice, 0));
    CUDA_SAFE_CALL(cuCtxCreate(&context, 0, cuDevice));
    CUDA_SAFE_CALL(cuLinkCreate(0, 0, 0, &linkState));
    CUDA_SAFE_CALL(cuLinkAddFile(linkState, CU_JIT_INPUT_LIBRARY, argv[1],
    0, 0, 0));
    CUDA_SAFE_CALL(cuLinkAddData(linkState, CU_JIT_INPUT_PTX,
    (void *)ptx, ptxSize, "dft_jit.ptx",
    0, 0, 0));
    size_t cubinSize;
    void *cubin;
    CUDA_SAFE_CALL(cuLinkComplete(linkState, &cubin, &cubinSize));
    CUDA_SAFE_CALL(cuModuleLoadData(&module, cubin));
    CUDA_SAFE_CALL(cuModuleGetFunction(&kernel, module, "grid_dft2d_cont"));

    for(int i = 0; i < variables.size(); i++) {
        const char * name;
        NVRTC_SAFE_CALL(nvrtcGetLoweredName(
        prog, 
        variables[i].c_str(), // name expression
        &name                         // lowered name
        ));
        CUdeviceptr variable_addr;
        // if(i == 0) {
        //     CUDA_SAFE_CALL(cuModuleGetGlobal(&variable_addr, NULL, module, name));
        //    CUDA_SAFE_CALL(cuMemAlloc(&variable_addr, 128* sizeof(double)));
        // }
        if(i == 1) {
        double value[128]= {1.0, 0.0, 1.0, 0.0, 
      1.0, 0.0, 1.0, 0.0, 
      1.0, 0.0, 1.0, 0.0, 
      1.0, 0.0, 1.0, 0.0, 
      1.0, 0.0, 0.92387953251128674, (-0.38268343236508978), 
      0.99518472667219693, (-0.098017140329560604), 0.88192126434835505, (-0.47139673682599764), 
      0.98078528040323043, (-0.19509032201612825), 0.83146961230254524, (-0.55557023301960218), 
      0.95694033573220882, (-0.29028467725446233), 0.77301045336273699, (-0.63439328416364549), 
      1.0, 0.0, 0.70710678118654757, (-0.70710678118654757), 
      0.98078528040323043, (-0.19509032201612825), 0.55557023301960218, (-0.83146961230254524), 
      0.92387953251128674, (-0.38268343236508978), 0.38268343236508978, (-0.92387953251128674), 
      0.83146961230254524, (-0.55557023301960218), 0.19509032201612825, (-0.98078528040323043), 
      1.0, 0.0, 0.38268343236508978, (-0.92387953251128674), 
      0.95694033573220882, (-0.29028467725446233), 0.098017140329560604, (-0.99518472667219693), 
      0.83146961230254524, (-0.55557023301960218), (-0.19509032201612825), (-0.98078528040323043), 
      0.63439328416364549, (-0.77301045336273699), (-0.47139673682599764), (-0.88192126434835505), 
      1.0, 0.0, 0.0, (-1.0), 
      0.92387953251128674, (-0.38268343236508978), (-0.38268343236508978), (-0.92387953251128674), 
      0.70710678118654757, (-0.70710678118654757), (-0.70710678118654757), (-0.70710678118654757), 
      0.38268343236508978, (-0.92387953251128674), (-0.92387953251128674), (-0.38268343236508978), 
      1.0, 0.0, (-0.38268343236508978), (-0.92387953251128674), 
      0.88192126434835505, (-0.47139673682599764), (-0.77301045336273699), (-0.63439328416364549), 
      0.55557023301960218, (-0.83146961230254524), (-0.98078528040323043), (-0.19509032201612825), 
      0.098017140329560604, (-0.99518472667219693), (-0.95694033573220882), 0.29028467725446233, 
      1.0, 0.0, (-0.70710678118654757), (-0.70710678118654757), 
      0.83146961230254524, (-0.55557023301960218), (-0.98078528040323043), (-0.19509032201612825), 
      0.38268343236508978, (-0.92387953251128674), (-0.92387953251128674), 0.38268343236508978,
      (-0.19509032201612825), (-0.98078528040323043), (-0.55557023301960218), 0.83146961230254524, 
      1.0, 0.0, (-0.92387953251128674), (-0.38268343236508978), 
      0.77301045336273699, (-0.63439328416364549), (-0.95694033573220882), 0.29028467725446233, 
      0.19509032201612825, (-0.98078528040323043), (-0.55557023301960218), 0.83146961230254524, 
      (-0.47139673682599764), (-0.88192126434835505), 0.098017140329560604, 0.99518472667219693};
             CUDA_SAFE_CALL(cuModuleGetGlobal(&variable_addr, NULL, module, name));
    CUDA_SAFE_CALL(cuMemcpyHtoD(variable_addr, &value, sizeof(value)));
        }
    }

// NVRTC_SAFE_CALL(nvrtcGetLoweredName(
// prog,
// kernel_name_vec[i].c_str(), // name expression
// &name // lowered name
// ));

 
    double *X = new double[64];
    double *Y = new double[64];
    for(int i = 0; i < 64; i++) {
        X[i] = 1;
        Y[i] = 0;
    }
    for (int i = 0; i < 64; i++) {
        std::cout << X[i] << "\n";
    }
    std::cout << "\n";
    std::cout << "numBlocks " << numBlocks << std::endl;
    std::cout << "X in host is " << X[10] << std::endl;
    CUdeviceptr dX, dY, dP;
    //double  *hp1 = new double[512];
    CUDA_SAFE_CALL(cuMemAlloc(&dX, 64* sizeof(double)));
    CUDA_SAFE_CALL(cuMemcpyHtoD(dX, X, 64* sizeof(double)));
    CUDA_SAFE_CALL(cuMemAlloc(&dY, 64* sizeof(double)));
    CUDA_SAFE_CALL(cuMemcpyHtoD(dY, Y, 64* sizeof(double)));
    //init_grid_dft2d_cont(kernel, module);
    // Execute parent kernel.
    void *args[] = { &dY, &dX};
    init_grid_dft2d_cont();
    CUDA_SAFE_CALL(
    cuLaunchKernel(kernel,
    1, 1, 1, // grid dim
    1, 1, 1, // block dim
    0, NULL, // shared mem and stream
    args, 0)); // arguments
    CUDA_SAFE_CALL(cuCtxSynchronize());
    // Retrieve and print output.
    CUDA_SAFE_CALL(cuMemcpyDtoH(X, dX, 64*sizeof(double)));
    CUDA_SAFE_CALL(cuMemcpyDtoH(X, dX, 64*sizeof(double)));
    //destroy_grid_dft2d_cont();
    return 0;
}
